#
# Copyright (C) 2013-2019 University of Amsterdam
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

LatentGrowthCurve <- function(jaspResults, dataset, options, ...) {
  jaspResults[["optionslist"]] <- createJaspHtml(paste(capture.output(str(options)), collapse = "\n"),
                                                 class = "jasp-code", position = 0, title = "Options")
  
  jaspResults[["optionslist2"]] <- createJaspHtml(paste(capture.output(dput(options)), collapse = "\n"),
                                                 class = "jasp-code", position = 0, title = "Options")
  
  ready <- length(options$variables) > 2
  
  if (ready)
    jaspResults[["model_syntax"]] <- createJaspHtml(
      .lgcmOptionsToMod(options, FALSE), class = "jasp-code", position = 1, title = "Model Syntax"
    )
  
  # Preprocess options
  options <- .lgcmPreprocessOptions(options)
  
  # Read dataset
  dataset <- .lgcmReadData(dataset, options)
  
  # Error checking
  errors <- .lgcmCheckErrors(dataset, options)
  
  # Create model container
  modelContainer <- .lgcmModelContainer(jaspResults, options)
  
  # output
  .lgcmFitTable(modelContainer, dataset, options, ready)
  
}

# Preprocessing functions ----
.lgcmPreprocessOptions <- function(options) {
  # No preprocessing necessary (yet)
  return(options)
}

.lgcmReadData <- function(dataset, options) {
  if (!is.null(dataset)) return(dataset)
  .readDataSetToEnd(columns = c(options$variables, options$regressions, options$covariates))
}

.lgcmCheckErrors <- function(dataset, options) {
  # some error check
  return(TRUE)
}

# Results functions ----
.lgcmComputeResults <- function(modelContainer, dataset, options) {
  lgcmResult <- try(lavaan::growth(
    model           = .lgcmOptionsToMod(options),
    data            = dataset,
    se              = ifelse(options$se == "bootstrap", "standard", options$se),
    mimic           = options$mimic,
    estimator       = options$estimator,
    std.ov          = options$std,
    missing         = options$missing
  ))
  
  if (inherits(lgcmResult, "try-error")) {
    modelContainer$setError(paste(
      "Model error:", 
      .decodeVarsInMessage(names(dataset), attr(lgcmResult, "condition")$message))
    )
    return()
  }
  
  admissible <- .withWarnings(lavaan:::lav_object_post_check(lgcmResult))
  
  if (!admissible$value) {
    modelContainer$setError(paste(
      "The model is not admissible:", 
      .decodeVarsInMessage(names(dataset), admissible$warnings[[1]]$message))
    )
  }
  
  if (!lgcmResult@optim$converged) {
    modelContainer$setError("The model could not be estimated due to nonconvergence.")
  }
  
  if (lgcmResult@test[[1]]$df < 0) {
    modelContainer$setError("The model could not be estimated: No degrees of freedom left.")
  }
  
  
  # Bootstrapping with interruptible progress bar
  if (options$se == "bootstrap") {
    startProgressbar(options$bootstrapNumber)
    
    boot_1      <- lavaan::bootstrapLavaan(lgcmResult, R = 1)
    bootres     <- matrix(0, options$bootstrapNumber, length(boot_1))
    bootres[1,] <- boot_1
    for (i in 2:options$bootstrapNumber) {
      bootres[i,] <- lavaan::bootstrapLavaan(lgcmResult, 1)
      progressbarTick()
    }
    
    lgcmResult@boot       <- list(coef = bootres)
    lgcmResult@Options$se <- "bootstrap"
  }
  
  # Save cfaResult as state so it's available even when opts don't change
  modelContainer[["model"]] <- createJaspState(lgcmResult)
  return(lgcmResult)
}

.lgcmOptionsToMod <- function(options, base64 = TRUE) {
  if (!base64) .v <- I
  timings <- sapply(options$timings, function(t) t$timing)
  
  # Header info
  Hed <- paste0(
    "# -------------------------------------------\n",
    "# Latent Growth Curve model generated by JASP\n", 
    "# -------------------------------------------\n"
  )
  
  # Basic LGCM curve information
  Int <- if (options$intercept)
    paste("I =~", paste0("1*", .v(options$variables), collapse = " + "))
  else NULL
  Lin <- if (options$linear) 
    paste("\nL =~", paste0(timings, "*", .v(options$variables), collapse = " + "))
  else NULL
  Qua <- if (options$quadratic)
    paste("\nQ =~", paste0(timings^2, "*", .v(options$variables), collapse = " + "))
  else NULL
  Cub <- if (options$cubic)
    paste("\nC =~", paste0(timings^3, "*", .v(options$variables), collapse = " + "))
  else NULL
  LGC <- paste0("\n# Growth curve\n", Int, Lin, Qua, Cub)
  
  curve <- c("I", "L", "Q", "C")[c(options$intercept, options$linear, options$quadratic, options$cubic)]
  
  # Covarying latents
  if (!options$covar) {
    Cov <- "\n\n# Suppress latent covariance"
    for (i in seq_along(curve))
      for (j in seq_along(curve))
        if (i < j) Cov <- paste0(Cov, "\n", curve[i], " ~~ 0*", curve[j])
  } else {
    Cov <- NULL
  }
  
  # Add regressions
  Reg <- if (length(options$regressions) > 0)
    paste0("\n\n# Regressions\n", paste(curve, collapse = " + "), " ~ ", 
           paste(.v(options$regressions), collapse = " + "))
  else NULL
  
  # Add time-varying covariates
  # eww this is hard
  
  # Put everything together
  paste0(Hed, LGC, Cov, Reg)
}

# Output functions ----
.lgcmModelContainer <- function(jaspResults, options) {
  if (!is.null(jaspResults[["modelContainer"]])) {
    modelContainer <- jaspResults[["modelContainer"]]
  } else {
    modelContainer <- createJaspContainer()
    modelContainer$dependOn(c(
      "variables", "regressions", "covariates", "timings", 
      "intercept", "linear", "quadratic", "cubic", "covar",
      "se", "bootstrapNumber"
    ))
    jaspResults[["modelContainer"]] <- modelContainer
  }
  
  return(modelContainer)
}

.lgcmFitTable <- function(modelContainer, dataset, options, ready) {
  if (!is.null(modelContainer[["maintab"]])) return()
  maintab <- createJaspTable("Chi-square Test")
  maintab$addColumnInfo(name = "mod",    title = "Model",        type = "string")
  maintab$addColumnInfo(name = "chisq",  title = "\u03a7\u00b2", type = "number", format = "dp:3")
  maintab$addColumnInfo(name = "df",     title = "df",           type = "integer")
  maintab$addColumnInfo(name = "pvalue", title = "p",            type = "number", format = "dp:3;p:.001")
  modelContainer[["maintab"]] <- maintab
  
  # add data to the table!
  if (!ready) return()
  lgcmResult <- .lgcmComputeResults(modelContainer, dataset, options)
  if (modelContainer$getError()) return()
  
  fm <- lavaan::fitMeasures(lgcmResult)
  maintab[["mod"]]    <- c("Baseline model", "Growth curve model")
  maintab[["chisq"]]  <- fm[c("baseline.chisq", "chisq")]
  maintab[["df"]]     <- fm[c("baseline.df", "df")]
  maintab[["pvalue"]] <- c(NA, fm["pvalue"])
}


.lgcmPlotCurve <- function(lgcmResult) {
  # plot the individual-level growth curves
  preds <- lavaan::predict(lgcmResult)
  preds <- cbind(preds, matrix(0, nrow(preds), 4 - ncol(preds)))
  xrange <- range(sapply(options$timings, function(t) t$timing))
  xx <- seq(xrange[1], xrange[2], length.out = 1000)
  df_wide <- data.frame(xx = xx, apply(preds, 1, function(b) b[1] + xx*b[2] + xx^2*b[3] + xx^3*b[4]))
  df_long <- gather(df_wide, key = "Participant", value = "Val", -"xx")
  
  ggplot(df_long, aes(x = xx, y = Val, colour = Participant)) + 
    geom_line(alpha = min(1, 1/log(nrow(preds)))) +
    scale_colour_manual(values = rep("#454545", nrow(preds)), guide = FALSE) +
    labs(y = "Value", x = "Time") +
    theme_minimal()
}
